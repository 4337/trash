Koncepcja jest prosta, mamy stan procesora oraz fargment kodu prowadzący do błędu.
Na podstawie fragmentu posiadanego kodu ze zrzutu pamięci lokalizujemy "podatną" funkcje.
Funckja to StringCchCopyNEx która operuje na prostych typach danych (tablice znaków).
Wiemy również że tylko dwa ze wszystkich rejsetrów procesora które są istotne w przebiegu wykonania 
funkcji wskazują na pamięć dynamiczną EBX (źródło), EDX (cel), korespondują one 
z argumentami pszSrc i pszDest. 
Reszta rejstrów EDI, EAX, ESI służą jako liczniki i indeksy w wykonowywanej pętli kopiującej dane.
Rejstr ECX służy jako zmienna tymczasowa przy procesie kopiowania.
Pozostałe rejstry nie mają znaczenia.
Wstępnie możemy również powiedzieć że mamy 13 wywołań StringCchCopyNEx w IE11, są to oczywiście 
wywołania bezpośrednie.
Wiemy że funkcja to __fastcall więc nie ma sensu wyszukiewanie na stosie  (EBP||ESP) referencji do pszDest oraz
pszSrc (są przekazywane przez ECX oraz EDX) - przynajmniej w samym wywołaniu StringCchCopyNEx, a 
nie dysponujemy "callstackiem".
Wiemy że funkcja nie ma FPO więc ESP i EBP jest wykorzystywany jako wskaźnik stosu, argumentów i zmiennych lokalych.
Wiemy że rozmiar docelowego buffora wynosi +-0x0a bajtów.
Adres bufora źródłowego wskazywnageo przez rejestr EBX (245f3000) ma wysoką wartość, jeśli ktoś kiedyś pracował 
przy ekspolitacji błędów rezydujących na stercie w Windows to wie że tak wysokie adresy jeśli w ogóle to są wykorzystywane 
przez znacznie większe wilkości danych niż +-0x0A to trochę psuje nam początkowe założenie co do 
typu błędu z jakim mamy doczynienia, ale narazie jesteśmy tylko na etapie założeń

   
------------------------------------------------------------------------------------
xref : wstępnie 13 wywołań StringCchCopyNEx 

72E9F780 | 8BFF                     | mov edi,edi                                  | __fastcall StringCchCopyNEx
72E9F782 | 55                       | push ebp                                     |
72E9F783 | 8BEC                     | mov ebp,esp                                  |

72E9F785 | 83EC 18                  | sub esp,18                                   |

72E9F788 | 53                       | push ebx                                     | ;store ebx value
72E9F789 | 56                       | push esi                                     | ;store esi value

72E9F78A | 8B75 18                  | mov esi,dword ptr ss:[ebp+18]                | ;esi = dwFlags
72E9F78D | 8BD9                     | mov ebx,ecx                                  | ;ebx = ecx = arg0 = pszDest

72E9F78F | 33C0                     | xor eax,eax                                  | ;eax = 0

72E9F791 | 8955 F4                  | mov dword ptr ss:[ebp-C],edx                 | ;[ebp-C] = local_var0xc = edx = arg1 = cchDest
72E9F794 | 895D FC                  | mov dword ptr ss:[ebp-4],ebx                 | ;[ebp-4] = local_var0x4 = ebx = arg0 = pszDest

72E9F797 | 8BCA                     | mov ecx,edx                                  | ;ecx = edx = arg1 = cchDest

72E9F799 | 81E6 00010000            | and esi,100                                  | ;if( !( esi = dwFlags  & 0x100)  ) 
72E9F79F | 0F85 62F81F00            | jne <mshtml._dwFlags_and_0x4_false_>         |

72E9F7A5 | 85C9                     | test ecx,ecx                                 | ;if( cchDest == 0 )
72E9F7A7 | 0F84 6EF81F00            | je <mshtml._ret_0x80070057_>                 |

72E9F7AD | 81F9 FFFFFF7F            | cmp ecx,7FFFFFFF                             | ;if ( (signed) cchDest > 0x7FFFFFFF )
72E9F7B3 | 0F87 62F81F00            | ja <mshtml._ret_0x80070057_>                 |

72E9F7B9 | 85C0                     | test eax,eax                                 | ;eax jest modyfikowany warunkowo //wyzej = wynik skoku
72E9F7BB | 0F88 22F91F00            | js <mshtml.__g_return_83AF83_>               | ;if( EAX = ret_val < 0 )

72E9F7C1 | 57                       | push edi                                     | ;store edi value

72E9F7C2 | 8B7D 0C                  | mov edi,dword ptr ss:[ebp+C]                 | ;edi = [ebp + 0xc] = arg3 = cchToCopy
72E9F7C5 | 8BD3                     | mov edx,ebx                                  | ;edx = ebx =  arg0 = pszDest
72E9F7C7 | 8955 F0                  | mov dword ptr ss:[ebp-10],edx                |
72E9F7CA | 8BC1                     | mov eax,ecx                                  | ;
72E9F7CC | 8945 EC                  | mov dword ptr ss:[ebp-14],eax                |

72E9F7CF | 81FF FFFFFF7F            | cmp edi,7FFFFFFF                             | ;if( (unsigned) cchToCopy >= 0x7FFFFFFF )
72E9F7D5 | 0F83 4AF81F00            | jae <mshtml._unsigned_bigerOrEqual_0x7FFFFFF |

72E9F7DB | 8B5D 08                  | mov ebx,dword ptr ss:[ebp+8]                 | ;ebx = arg2 = pszSrc
72E9F7DE | 85F6                     | test esi,esi                                 | ;if( ESI != 0 )
72E9F7E0 | 0F85 59F81F00            | jne mshtml.7309F03F                          |

72E9F7E6 | 33F6                     | xor esi,esi                                  | esi:_DbgUiRemoteBreakin@4

72E9F7E8 | F745 18 00E0FFFF         | test dword ptr ss:[ebp+18],FFFFE000          | if (! (dwFlags & 0xFFFFE000) )
72E9F7EF | 0F85 5EF81F00            | jne mshtml.7309F053                          |

72E9F7F5 | 85C9                     | test ecx,ecx                                 | ;if(  arg1 = cchDest == 0 ) ??!!??
72E9F7F7 | 0F84 A7F81F00            | je <mshtml.__epilog_0_0x8145FE72__>          | ;  prawie epilog 

72E9F7FD | 2BF9                     | sub edi,ecx                                  | ;edi =  (edi = arg3 = cchToCopy) - (ecx =  arg1 = cchDest) ??!!??
72E9F7FF | 8975 F8                  | mov dword ptr ss:[ebp-8],esi                 | ;
72E9F802 | 8BC1                     | mov eax,ecx                                  | ;eax = ecx =  arg1 = cchDest ??!!??
72E9F804 | 2BDA                     | sub ebx,edx                                  | ;ebx =( arg2 = pszSrc) -  (edx = arg0 = pszDest) //ustawienie ebx = &pszSrc[0]

72E9F806 | 8D0C07                   | lea ecx,dword ptr ds:[edi+eax]               | ;__str_copy_loop_
72E9F809 | 85C9                     | test ecx,ecx                                 | ecx:_DbgUiRemoteBreakin@4
72E9F80B | 74 1A                    | je <mshtml.__cchToCopy_is_less_cchDest_or_en |
72E9F80D | 0FB70C13                 | movzx ecx,word ptr ds:[ebx+edx]              | ;e/cx = pszSrc[N] ; !!!!!!!!! BUG !!!!!!!!!!
72E9F811 | 66:85C9                  | test cx,cx                                   | ;if( pszSrc[N] == '\0' )
72E9F814 | 74 11                    | je <mshtml.__cchToCopy_is_less_cchDest_or_en |
72E9F816 | 66:890A                  | mov word ptr ds:[edx],cx                     | ;else : *pszDest = pszSrc[n] //copy char
72E9F819 | 46                       | inc esi                                      | ;esi = current copied data size
72E9F81A | 83C2 02                  | add edx,2                                    | ;pszDest++
72E9F81D | 83E8 01                  | sub eax,1                                    | ;--cchDest //zmniejsz cchDest
72E9F820 | 75 E4                    | jne <mshtml.__str_copy_loop_0x1AEF83_>       |

72E9F822 | E9 A4F81F00              | jmp mshtml.7309F0CB                          |
72E9F827 | 85C0                     | test eax,eax                                 |
72E9F829 | 0F84 9CF81F00            | je mshtml.7309F0CB                           |
72E9F82F | 8B4D F4                  | mov ecx,dword ptr ss:[ebp-C]                 | ecx:_DbgUiRemoteBreakin@4, [ebp-C]:__except_handler4
72E9F832 | 33C0                     | xor eax,eax                                  |
72E9F834 | 66:8902                  | mov word ptr ds:[edx],ax                     |
72E9F837 | 8B45 FC                  | mov eax,dword ptr ss:[ebp-4]                 |
72E9F83A | 8D1470                   | lea edx,dword ptr ds:[eax+esi*2]             |
72E9F83D | 8BC1                     | mov eax,ecx                                  | ecx:_DbgUiRemoteBreakin@4
72E9F83F | 2BC6                     | sub eax,esi                                  | esi:_DbgUiRemoteBreakin@4
72E9F841 | 8955 F0                  | mov dword ptr ss:[ebp-10],edx                |
72E9F844 | 8B75 F8                  | mov esi,dword ptr ss:[ebp-8]                 | esi:_DbgUiRemoteBreakin@4
72E9F847 | 8945 E8                  | mov dword ptr ss:[ebp-18],eax                |
72E9F84A | 8945 EC                  | mov dword ptr ss:[ebp-14],eax                |
72E9F84D | 85F6                     | test esi,esi                                 | esi:_DbgUiRemoteBreakin@4
72E9F84F | 78 54                    | js mshtml.72E9F8A5                           |
72E9F851 | 8B5D 18                  | mov ebx,dword ptr ss:[ebp+18]                |
72E9F854 | F7C3 00020000            | test ebx,200                                 |
72E9F85A | 74 05                    | je mshtml.72E9F861                           |
72E9F85C | 83F8 01                  | cmp eax,1                                    |
72E9F85F | 77 1D                    | ja mshtml.72E9F87E                           |
72E9F861 | 85F6                     | test esi,esi                                 | esi:_DbgUiRemoteBreakin@4
72E9F863 | 78 40                    | js mshtml.72E9F8A5                           |
72E9F865 | 8B4D 10                  | mov ecx,dword ptr ss:[ebp+10]                | ecx:_DbgUiRemoteBreakin@4
72E9F868 | 85C9                     | test ecx,ecx                                 | ecx:_DbgUiRemoteBreakin@4
72E9F86A | 75 41                    | jne mshtml.72E9F8AD                          |
72E9F86C | 8B4D 14                  | mov ecx,dword ptr ss:[ebp+14]                | ecx:_DbgUiRemoteBreakin@4, [ebp+14]:__RtlUserThreadStart+2F
72E9F86F | 85C9                     | test ecx,ecx                                 | ecx:_DbgUiRemoteBreakin@4
72E9F871 | 75 3E                    | jne mshtml.72E9F8B1                          |
72E9F873 | 8BC6                     | mov eax,esi                                  | esi:_DbgUiRemoteBreakin@4
72E9F875 | 5F                       | pop edi                                      | edi:_DbgUiRemoteBreakin@4
72E9F876 | 5E                       | pop esi                                      | esi:_DbgUiRemoteBreakin@4
72E9F877 | 5B                       | pop ebx                                      |
72E9F878 | 8BE5                     | mov esp,ebp                                  |
72E9F87A | 5D                       | pop ebp                                      |
72E9F87B | C2 1400                  | ret 14                                       |

-------------------------------------------------------------------------------------

Registers:
eax=0000000a ebx=245f3000 ecx=00000009 edx=0cdc3fec esi=00000000 edi=ffffffff
eip=6f48f97d esp=156ce738 ebp=156ce75c iopl=0         no up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206

ebp -> 8c e7 6c 15 b4 f8 48 6f ec 6f 3b 31 09 00 00 00  ..l...Ho.o;1....
edx -> 00 00 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0  ................

Code disassembly:
   6F48F96D |     2bf9 | sub edi, ecx  ;edi =  cchToCopy - cchDest
   6F48F96F |   8975f8 | mov [ebp-0x8], esi
   6F48F972 |     8bc1 | mov eax, ecx  ;eax = cchDest
   6F48F974 |     2bda | sub ebx, edx
   6F48F976 |   8d0c07 | lea ecx, [edi+eax]
   6F48F979 |     85c9 | test ecx, ecx
   6F48F97B |     741a | jz mshtml!ordinal107+0x2c2c7
 * 6F48F97D | 0fb70c13 | movzx ecx, word [ebx+edx]
   6F48F981 |   6685c9 | test cx, cx
   6F48F984 |     7411 | jz mshtml!ordinal107+0x2c2c7
   6F48F986 |   66890a | mov [edx], cx
   6F48F989 |       46 | inc esi
   6F48F98A |   83c202 | add edx, 0x2
   
----------------------------------------------------------------------------------------

Z analizy wiemy że błąd pojawia się w pierwszej iterakcji pętli, już przy próbie skopiowania 
*pszDest = pszSrc[0], wskazuje na to wartośći rejestru ESI = 00000000.
Błędna instrukcja to próba odczytu wartości WORD z bufora źródłowego wskazywanego przez rejestr EBX (245f3000).
Z wartości resjestrów EBX (źródło), EDX (cel) i porównania ich z wartością resjtru ESP i EBP (normalna ramka stosu, brak FPO) możemy wywnioskować 
że ciągi znaków na których operuje funkcja to pamięć dynamiczna - to może umożliwić pewne założenia :
Pamięć dynamiczna i błąd w pierwszej interacji pętli może wskazywać na błąd typu UAF.
To zkolei może wyjaśniać dlaczego "repro" jest nie stabilne (garbage collerctor - pamieć być może nie jest zwalaniana w każdym przydpadku,
lub jest ponownie użyta przez inny fragment kodu co nieprowadzi odrazu do błędu.
...

